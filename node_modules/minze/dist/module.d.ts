export declare type Attrs = ReadonlyArray<MinzeAttr>;

export declare type EventListeners = ReadonlyArray<MinzeEvent>;

/**
 * Minze class with multiple static methods and properties for common tasks.
 */
declare class Minze {
    /**
     * The current Minze version.
     */
    static readonly version = "__VERSION__";
    /**
     * Defines a custom element.
     *
     * @param name - The name of the custom element.
     * @param element - The element extending the MinzeElement class.
     *
     * @example
     * ```
     * class MyElement extends MinzeElement {}
     * Minze.define('my-element', MyElement)
     * ```
     */
    static define(name: string, element: typeof MinzeElement): void;
    /**
     * Defines multiple custom elements.
     *
     * All class names have to be either PascalCase or camelCase for automatic dash-case name conversion.
     * Example: `MinzeElement` will be registered as `<minze-element></minze-element>`.
     *
     * @param elements - A module object or an array of custom Minze elements.
     *
     * @example
     * ```
     * import * as Elements from './module'
     * Minze.defineAll(Elements)
     * // or
     * import { MinzeElement, MinzeElementTwo } from './module'
     * Minze.define([ MinzeElement, MinzeElementTwo ])
     * ```
     */
    static defineAll(elements: typeof MinzeElement[] | Record<string, typeof MinzeElement>): void;
    /**
     * Dispatches a custom event on the `window` object.
     *
     * @param eventName - The name of the event.
     * @param detail - The detail data to be passed with the event.
     *
     * @example
     * ```
     * Minze.cast('minze:update', { amount: 10 })
     * ```
     */
    static cast(eventName: string, detail?: unknown): void;
    /**
     * Adds an event listener to the `window` object
     * for the provided event name and callback function.
     *
     * @param eventName - The name of the event.
     * @param callback - The callback function to be called when the event is dispatched.
     *
     * @example
     * ```
     * Minze.listen('minze:update', (event) => {})
     * ```
     */
    static listen(eventName: string, callback: (event: Event) => void): void;
    /**
     * Removes event listener based on the provided event name and
     * callback function from the `window` object.
     *
     * @param eventName - The name of the event.
     * @param callback - The callback function to be removed.
     *
     * @example
     * ```
     * Minze.stopListen('minze:update', (event) => {})
     * ```
     */
    static stopListen(eventName: string, callback: (event: Event) => void): void;
}
export { Minze }
export default Minze;

export declare type MinzeAttr = string | [name: string, value?: unknown];

export declare type MinzeAttrs = Attrs;

/**
 * MinzeElement: Can be used to extend from to create custom web components.
 *
 * @example
 * ```
 * class MyElement extends MinzeElement {
 *   html = () => `<div>Hello Minze!</div>`
 * }
 * ```
 */
export declare class MinzeElement extends HTMLElement {
    [key: string]: unknown;
    constructor();
    /**
     * The current Minze version.
     */
    readonly version = "__VERSION__";
    /**
     * The class name of the component in dash-case.
     *
     * @example
     * ```
     * class MyElement exptends MinzeElement {}
     * MyElement.dashName
     * ```
     */
    static get dashName(): string;
    /**
     * Registers element as a custom web component.
     *
     * @param name - The name of the custom web component.
     *
     * @example
     * ```
     * class MyElement exptends MinzeElement {}
     * MyElement.define()
     * // or
     * MyElement.define('my-element')
     * ```
     */
    static define(name?: string): void;
    /**
     * Defines options for the web component.
     *
     * @example
     * ```
     * MyElement extends MinzeElement {
     *   options = {
     *     exposeAttrs: {
     *       rendered: true
     *     }
     *   }
     * }
     * ```
     */
    options?: {
        exposeAttrs?: {
            rendered?: boolean;
        };
    };
    /**
     * Defines properties that should be created as reactive.
     *
     * reactive takes a mixed array of strings and tuples:
     * [name, [ name, value, exposeAttr? ], ...]
     *
     * @example
     * ```
     * class MyElement extends MinzeElement {
     *   reactive = [
     *     'foo',
     *     ['active', false],
     *     ['amount', 0, true]
     *   ]
     * }
     * ```
     */
    reactive?: Reactive;
    /**
     * Defines attribute properties that should be created as reactive.
     *
     * attrs takes a mixed array of strings and tuples:
     * [name [ name, value? ], ...]
     *
     * @example
     * ```
     * class MyElement extends MinzeElement {
     *   attrs = [
     *     'foo',
     *     ['active'],
     *     ['amount', 0]
     *   ]
     * }
     * ```
     */
    attrs?: Attrs;
    /**
     * Defines attributes which should be observed.
     *
     * observedAttributes takes an array strings.
     *
     * @example
     * ```
     * class MyElement extends MinzeElement {
     *   static observedAttributes = ['active', 'amount']
     * }
     * ```
     */
    static observedAttributes?: string[];
    /**
     * Defines watchers with callbacks for reactive properties and attrs.
     * Whenever a property changes the watcher will be called.
     *
     * watch takes an array of tuples: [[ name, callback ], ...]
     *
     * @example
     * ```
     * class MyElement extends MinzeElement {
     *   watch = [
     *     ['active', (newValue, oldValue, key, target) => {}],
     *     ['amount', async (newValue, oldValue) => {}]
     *   ]
     * }
     * ```
     */
    watch?: Watch;
    /**
     * Defines event listeners that will be registered when the element is rendered.
     *
     * eventListeners takes an array of tuples: [[ eventTarget, eventName, callback ], ...]
     *
     * possible event targets are:
     * - global: window (limited to prevent event-listener-pollution)
     * - local: this, or any elements inside the shadow DOM (by passing a valid CSS selector string)
     *
     * @example
     * ```
     * class MyElement extends MinzeElement {
     *   eventListeners = [
     *     ['.my-class', 'click', () => {}],
     *     [window, 'resize', () => {}],
     *     [this, 'minze:event', () => {}]
     *   ]
     * }
     * ```
     */
    eventListeners?: EventListeners;
    /**
     * Defines the shadow DOM HTML content.
     *
     * @example
     * ```
     * class MyElement extends MinzeElement {
     *   html = () => `
     *     <div>Hello Minze!</div>
     *   `
     * }
     * ```
     */
    html?(): string;
    /**
     * Defines the shadow DOM styling.
     *
     * @example
     * ```
     * class MyElement extends MinzeElement {
     *   css = () => `
     *     :host {
     *       background: #000;
     *     }
     *   `
     * }
     * ```
     */
    css?(): string;
    /**
     * Creates the template for the shadow root, which will be inserted into the Shadow root.
     */
    private template;
    /**
     * Stores the previously rendered template.
     */
    private cachedTemplate;
    /**
     * Renders the template into the shadow DOM.
     * Removes any previously registered event listeners.
     * Attaches all new event listeners.
     *
     * @param force - Forces the re-rendering of the template regardless of caching.
     *
     * @example
     * ```
     * this.render()
     * ```
     */
    private render;
    /**
     * Re-renders the component template.
     *
     * @param force - Forces the re-rendering of the template regardless of caching.
     *
     * @example
     * ```
     * this.rerender()
     * ```
     */
    rerender(force?: boolean): void;
    /**
     * Selects the first matching element inside the shadow DOM.
     *
     * @param selectors - A valid CSS selector string.
     *
     * @example
     * ```
     * this.select('div')
     * ```
     */
    select<E extends Element = Element>(selectors: string): NonNullable<E> | null;
    /**
     * Selects element(s) inside the shadow DOM.
     *
     * @param selectors - A valid CSS selector string.
     *
     * @example
     * ```
     * this.selectAll('div')
     * ```
     */
    selectAll<E extends Element = Element>(selectors: string): NodeListOf<E> | null;
    /**
     * Exposes property as an attribute on the element.
     *
     * @param name - The name of the attribute.
     * @param value - The value for the attribute.
     *
     * @example
     * ```
     * this.exposeAttr('active', false)
     * ```
     */
    private exposeAttr;
    /**
     * Callback, executes a set of methods on reactive changes.
     *
     * @param type - The type of property that changed.
     * @param rootName - The name of the root property that changed.
     * @param rootProp - The value of the root property that changed.
     * @param target - The target of the property that changed.
     * @param key - The name of the property that changed.
     * @param newValue - The new value of the property that changed.
     * @param oldValue - The old value of the property that changed.
     *
     * @example
     * ```
     * this.reactiveChange(type, rootName, rootProp, target, prop, newValue, oldValue)
     * ```
     */
    private reactiveChange;
    /**
     * Makes a complex object deeply reactive.
     *
     * @param name - The name of the property.
     * @param prop - The property to be made reactive.
     * @param exposeAttr - Whether to expose the property as an attribute.
     *
     * @example
     * ```
     * this.makeComplexReactive('active', {deeply: {nested: true}}, true)
     * ```
     */
    private makeComplexReactive;
    /**
     * Makes a primitive value reactive.
     *
     * @param name - The name of the property.
     * @param prop - The property to be made reactive.
     * @param exposeAttr - Whether to expose the property as an attribute.
     *
     * @example
     * ```
     * this.makePrimitiveReactive('count', 99)
     * ```
     */
    private makePrimitiveReactive;
    /**
     * Makes provided property reactive.
     *
     * @param prop - The MinzeProp to be made reactive.
     *
     * @example
     * ```
     * this.registerProp(prop)
     * ```
     */
    private registerProp;
    /**
     * Makes provided property reactive to attribute changes on the component.
     *
     * @param attr - The MinzeAttr to be made reactive.
     *
     * @example
     * ```
     * this.registerAttr(attr)
     * ```
     */
    private registerAttr;
    /**
     * Adds or removes a provided event listener.
     *
     * @param eventTuple - The event tuple to be added or removed.
     * @param action - The action to be performed.
     *
     * @example
     * ```
     * this.registerEvent(this.eventListeners[0], 'add')
     * ```
     */
    private registerEvent;
    /**
     * Dispatches a custom event from the web component.
     *
     * It's a good idea to namespace the event name. For example: `minze:update`
     *
     * @param eventName - The name of the event to be dispatched.
     * @param detail - The detail data to be passed with the event.
     *
     * @example
     * ```
     * this.cast('minze:update', { amount: 10 })
     * ```
     */
    cast(eventName: string, detail?: unknown): void;
    /**
     * Lifecycle (Internal) - Runs whenever the element is appended into a document-connected element.
     */
    private connectedCallback;
    /**
     * Lifecycle (Internal) - Runs each time the element is disconnected from the document's DOM.
     */
    private disconnectedCallback;
    /**
     * Lifecycle (Internal) - Runs each time the element is moved to a new document.
     */
    private adoptedCallback;
    /**
     * Lifecycle (Internal) - Runs whenever one of the element's attributes is changed.
     *
     * @param name - The name of the attribute that was changed.
     * @param oldValue - The previous value of the attribute.
     * @param newValue - The new value of the attribute.
     */
    private attributeChangedCallback;
    /**
     * Lifecycle - Runs once at the start of the connectedCallback method.
     *
     * @example
     * ```
     * class MyElement extends MinzeElement {
     *   onStart = () => console.log('onStart')
     * }
     * ```
     */
    onStart?(): Promise<void> | void;
    /**
     * Lifecycle - Runs once after reactive properties are initialized.
     *
     * @example
     * ```
     * class MyElement extends MinzeElement {
     *   onReactive = () => console.log('onReactive')
     * }
     * ```
     */
    onReactive?(): Promise<void> | void;
    /**
     * Lifecycle - Runs once at the end of the connectedCallback method.
     *
     * @example
     * ```
     * class MyElement extends MinzeElement {
     *   onReady = () => console.log('onReady')
     * }
     * ```
     */
    onReady?(): Promise<void> | void;
    /**
     * Lifecycle - Runs once at the end of the disconnectedCallback method.
     *
     * @example
     * ```
     * class MyElement extends MinzeElement {
     *   onDestroy = () => console.log('onDestroy')
     * }
     * ```
     */
    onDestroy?(): Promise<void> | void;
    /**
     * Lifecycle - Runs once at the start of the adoptedCallback method.
     *
     * @example
     * ```
     * class MyElement extends MinzeElement {
     *   onMove = () => console.log('onMove')
     * }
     * ```
     */
    onMove?(): Promise<void> | void;
    /**
     * Lifecycle - Runs each time at before of every render.
     *
     * @example
     * ```
     * class MyElement extends MinzeElement {
     *   onRender = () => console.log('onRender')
     * }
     * ```
     */
    beforeRender?(): Promise<void> | void;
    /**
     * Lifecycle - Runs each time at the end of every render.
     *
     * @example
     * ```
     * class MyElement extends MinzeElement {
     *   onRender = () => console.log('onRender')
     * }
     * ```
     */
    onRender?(): Promise<void> | void;
    /**
     * Lifecycle - Runs each time at the start of the attributeChangedCallback method.
     *
     * This hook runs before the onStart lifecycle, if an attribute is set on the element:
     * `<minze-element text="Hello Minze!" /></minze-element>`
     *
     * @param name - The name of the attribute that was changed.
     * @param oldValue - The previous value of the attribute.
     * @param newValue - The new value of the attribute.
     *
     * @example
     * ```
     * class MyElement extends MinzeElement {
     *   beforeAttributeChange = (name, oldValue, newValue) => console.log('beforeAttributeChange')
     * }
     * ```
     */
    beforeAttributeChange?(name?: string, oldValue?: string | null, newValue?: string | null): Promise<void> | void;
    /**
     * Lifecycle - Runs each time at the end of the attributeChangedCallback method.
     *
     * This hook runs before the onStart lifecycle, if an attribute is set on the element:
     * `<minze-element text="Hello Minze!" /></minze-element>`
     *
     * @param name - The name of the attribute that was changed.
     * @param oldValue - The previous value of the attribute.
     * @param newValue - The new value of the attribute.
     *
     * @example
     * ```
     * class MyElement extends MinzeElement {
     *   onAttributeChange = (name, oldValue, newValue) => console.log('onAttributeChange')
     * }
     * ```
     */
    onAttributeChange?(name?: string, oldValue?: string | null, newValue?: string | null): Promise<void> | void;
}

export declare type MinzeEvent = [
eventTarget: string | MinzeElement | typeof window,
eventName: string,
callback: (event: Event) => void
];

export declare type MinzeEventListeners = EventListeners;

export declare type MinzeProp = string | [name: string, value: unknown, exposeAttr?: boolean];

export declare type MinzeReactive = Reactive;

export declare type MinzeWatch = Watch;

export declare type MinzeWatcher = [
name: string,
callback: (newValue?: any, // eslint-disable-line @typescript-eslint/no-explicit-any
oldValue?: any, // eslint-disable-line @typescript-eslint/no-explicit-any
key?: string, target?: object | typeof MinzeElement) => Promise<void> | void
];

export declare type Reactive = ReadonlyArray<MinzeProp>;

export declare type Watch = ReadonlyArray<MinzeWatcher>;

export { }
